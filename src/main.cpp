#include <meevax/posix/linker.hpp>
#include <meevax/system/syntactic_closure.hpp>
#include <meevax/utility/demangle.hpp>

#include <boost/cstdlib.hpp>

int main() try
{
  using namespace meevax::system;

  syntactic_closure program {scheme_report_environment<7>};

  // CFFI経由で呼び出すべきものだが手間の都合でここに雑に列挙
  {
    program.define<procedure>("display", [&](auto&& args)
    {
      for (const auto& each : args)
      {
        if (each.template is<string>()) // XXX DIRTY HACK
        {
          std::cout << static_cast<std::string>(each.template as<string>());
        }
        else
        {
          std::cout << each;
        }
      }
      return unit; // XXX DIRTY HACK
    });

    program.define<procedure>("emergency-exit", [&](auto&& args)
    {
      if (not args or not car(args).template is<number>())
      {
        std::exit(boost::exit_success);
      }
      else
      {
        // XXX DIRTY HACK
        std::exit(static_cast<int>(car(args).template as<number>()));
      }

      return unit; // XXX DIRTY HACK
    });

    // (dynamic-link-open <path>)
    program.define<procedure>("dynamic-link-open", [&](auto&& args)
    {
      if (auto length {std::distance(std::begin(args), std::end(args))}; length < 1)
      {
        throw error {pseudo_display("procedure dynamic-link-open expects a string for argument, but received nothing.")};
      }
      else if (auto s {car(args)}; not s.template is<string>())
      {
        throw error {pseudo_display(
                      "procedure dynamic-link-open expects a string for argument, but received ",
                      meevax::utility::demangle(s.access().type()),
                      " rest ", length, " argument",
                      (length < 2 ? " " : "s "),
                      "were ignored."
                    )};
      }
      else
      {
        return make<meevax::posix::linker>(s.template as<string>());
      }
    });

    // (dynamic-link-procedure <linker> <name>)
    program.define<procedure>("dynamic-link-procedure", [&](auto&& args)
    {
      if (auto length {std::distance(std::begin(args), std::end(args))}; length < 1)
      {
        throw error {pseudo_display("procedure dynamic-link-procedure expects two arguments (linker and string), but received nothing.")};
      }
      else if (length < 2)
      {
        throw error {pseudo_display("procedure dynamic-link-procedure expects two arguments (linker and string), but received only one argument.")};
      }
      else if (const auto& linker {car(args)}; not linker.template is<meevax::posix::linker>())
      {
        throw error {pseudo_display(
                      "procedure dynamic-link-open expects a linker for first argument, but received ",
                      meevax::utility::demangle(linker.access().type()),
                      " rest ", length - 1, " argument",
                      (length < 2 ? " " : "s "),
                      "were ignored."
                    )};
      }
      else if (const auto& name {cadr(args)}; not name.template is<string>())
      {
        throw error {pseudo_display(
                      "procedure dynamic-link-open expects a string for second argument, but received ",
                      meevax::utility::demangle(name.access().type()),
                      " rest ", length - 2, " argument",
                      (length < 3 ? " " : "s "),
                      "were ignored."
                    )};
      }
      else
      {
        const auto& linker_ {car(args).template as<meevax::posix::linker>()};
        const std::string& name_ {cadr(args).template as<string>()};
        return make<procedure>(
                 name_, // TODO リンクしてるライブラリ名を名前に含めること（#<procedure hoge from libhoge.so>）
                 linker_.template link<typename procedure::signature>(name_)
               );
      }
    });
  }

  for (program.open("/dev/stdin"); program.ready(); ) try
  {
    std::cerr << "\n> " << std::flush;
    const auto expression {program.read()};
    std::cerr << "\n; " << expression << std::endl;

    const auto executable {program.execute.compile(expression)};
    std::cerr << "; as " << executable << std::endl;

    const auto evaluation {program.execute(executable)};
    std::cerr << "; => " << std::flush;
    std::cout << evaluation << std::endl;
  }
  catch (const objective& something) // runtime exception generated by user code
  {
    std::cerr << something << std::endl;
    continue;
  }
  catch (const warning& warning)
  {
    std::cerr << warning << std::endl;
    continue;
  }
  catch (const exception& error) // runtime exception generated by core system
  {
    std::cerr << error << std::endl;
    continue; // TODO EXIT IF IN NON-INTARACTIVE MODE
  }

  return boost::exit_success;
}
catch (const std::exception& error)
{
  std::cout << "\x1b[1;31m" << "unexpected standard exception: \"" << error.what() << "\"" << "\x1b[0m" << std::endl;
  return boost::exit_exception_failure;
}
catch (...)
{
  std::cout << "\x1b[1;31m" << "unexpected exception occurred." << "\x1b[0m" << std::endl;
  return boost::exit_exception_failure;
}

