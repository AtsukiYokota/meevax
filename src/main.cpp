#include <meevax/system/syntactic_closure.hpp>

#include <boost/cstdlib.hpp>

int main() try
{
  using namespace meevax::system;

  syntactic_closure root {scheme_report_environment<7>};

  // CFFI経由で呼び出すべきものだが手間の都合でここに雑に列挙
  {
    root.define<procedure>("display", [&](auto&& args)
    {
      for (const auto& each : args)
      {
        if (each.template is<string>()) // XXX DIRTY HACK
        {
          std::cout << static_cast<std::string>(each.template as<string>());
        }
        else
        {
          std::cout << each;
        }
      }
      return unit; // XXX DIRTY HACK
    });

    root.define<procedure>("emergency-exit", [&](auto&& args)
    {
      if (not args or not car(args).template is<number>())
      {
        std::exit(boost::exit_success);
      }
      else
      {
        // XXX DIRTY HACK
        std::exit(static_cast<int>(car(args).template as<number>()));
      }

      return unit; // XXX DIRTY HACK
    });

    root.define<procedure>("link-procedure", [&](auto&& args)
    {
      return make<procedure>(
               "unknown",
               root.link<procedure>(
                 car(args).template as<string>(),
                 cadr(args).template as<string>()
               )
             );
    });
  }

  for (root.open("/dev/stdin"); root.ready(); ) try
  {
    std::cerr << "\n> " << std::flush;
    const auto expression {root.read()};
    std::cerr << "\n; " << expression << std::endl;

    const auto executable {root.execute.compile(expression)};
    std::cerr << "; as " << executable << std::endl;

    const auto evaluation {root.execute(executable)};
    std::cerr << "; => " << std::flush;
    std::cout << evaluation << std::endl;
  }
  catch (const objective& something) // runtime exception generated by user code
  {
    std::cerr << something << std::endl;
    continue;
  }
  catch (const warning& warning)
  {
    std::cerr << warning << std::endl;
    continue;
  }
  catch (const exception& error) // runtime exception generated by core system
  {
    std::cerr << error << std::endl;
    continue; // TODO EXIT IF IN NON-INTARACTIVE MODE
  }

  return boost::exit_success;
}
catch (const std::exception& error)
{
  std::cout << "\x1b[1;31m" << "unexpected standard exception: \"" << error.what() << "\"" << "\x1b[0m" << std::endl;
  return boost::exit_exception_failure;
}
catch (...)
{
  std::cout << "\x1b[1;31m" << "unexpected exception occurred." << "\x1b[0m" << std::endl;
  return boost::exit_exception_failure;
}

