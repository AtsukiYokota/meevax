#include <meevax/system/module.hpp>

#include <boost/cstdlib.hpp>

int main()
{
  using namespace meevax::system;

  std::cerr << "starting boot seqence.\n" << std::endl;

  module root {};

  // CFFI経由で呼び出すべきものだが手間の都合でここに雑に列挙
  {
    root.define<procedure>("display", [&](auto&& args)
    {
      for (auto each : args)
      {
        if (each.template is<string>()) // XXX DIRTY HACK
        {
          std::cout << static_cast<std::string>(each.template as<string>());
        }
        else
        {
          std::cout << each;
        }
      }
      return unit; // XXX DIRTY HACK
    });

    root.define<procedure>("emergency-exit", [&](auto&& args)
    {
      if (not args or not car(args).template is<number>())
      {
        std::exit(boost::exit_success);
      }
      else
      {
        // XXX DIRTY HACK
        std::exit(static_cast<int>(car(args).template as<number>()));
      }

      return unit; // XXX DIRTY HACK
    });

    root.define<procedure>("link-procedure", [&](auto&& args)
    {
      return make<procedure>(
               "unknown",
               root.link<procedure>(
                 car(args).template as<string>(),
                 cadr(args).template as<string>()
               )
             );
    });
  }

  std::cerr << "\n"
            << "\twelcome, wizard\n"
            << "\n"
            << "you have control" << std::endl;

  for (root.open("/dev/stdin"); root.ready(); ) try
  {
    std::cerr << "\n> " << std::flush;
    const auto expression {root.read()};
    std::cerr << "\n; " << expression << std::endl;

    const auto executable {root.execute.compile(expression)};
    std::cerr << "; as " << executable << std::endl;

    const auto evaluation {root.execute(executable)};
    std::cerr << "; => " << std::flush;
    std::cout << evaluation << std::endl;
  }
  catch (const cursor& something) // runtime exception generated by user code
  {
    std::cerr << something << std::endl;
    continue;
  }
  catch (const warning& warning)
  {
    std::cerr << warning << std::endl;
    continue;
  }
  catch (const exception& error) // runtime exception generated by core system
  {
    std::cerr << error << std::endl;
    continue; // TODO EXIT IF IN NON-INTARACTIVE MODE
  }
  catch (const std::exception& error)
  {
    std::cerr << "\x1b[1;31m"
              << "unexpected standard exception: \"" << error.what() << "\"\n"
              << "this maybe implementation bug. report this to developer.\n"
              << "shutting down meevax system.\n"
              << "\x1b[0m";
    return boost::exit_exception_failure;
  }

  return boost::exit_success;
}

