; (define null?
;   (lambda (x)
;     EQUx))

; EQU Qa
; EQU QU

; (define not
;   (lambda (x)
;     (if x #false #true)))

; N#t
; N#f

; NEQaQa
; NEQaQb

; (define and
;   (lambda (x y)
;     (if x (if y #true #false) #false)))

; (and N(pair? Qa) EQaQa)
; (and N(pair? Qa) EQaQb)

; (define append
;   (lambda (x y)
;     (if EQUx y P Hx (append Tx y))))

; (append Q(a b) Q(c d))
; (append QU     Q(c d))

; (define list
;   (lambda (x y)
;     P x P y QU))

; Dzip Y
;   (lambda (f)
;     (lambda (x y)
;       (if (and EQUx EQUy) QU
;           (if (and (pair? x) (pair? y)) P (list Hx Hy) (f Tx Ty) QU))))

; (zip Q(x y z) Q(a b c)); => ((x a) (y b) (z c))

; Dassoc Y
;   (lambda (f)
;     (lambda (x y)
;       (if EQUx QU
;           (if EQUy x
;               (if E HHy x HTHy
;                   (f x Ty))))))

; (assoc Qx Q(        (x a) (y b))); => a
; (assoc Qx Q((x new) (x a) (y b))); => new

Deval Y
  (lambda (f)
    (lambda (e a)
      Dand
        (lambda (x y)
          (if x (if y #t #f) #f)))
      Dappend Y
        (lambda (g)
          (lambda (x y)
            (if EQUx y PHx (g Tx y))))
      Dzip Y
        (lambda (g)
          (lambda (x y)
            (if (and EQUx EQUy) QU
                (if (and P?x P?y) P (list Hx Hy) (g Tx Ty) QU))))
      Dassoc Y
        (lambda (g)
          (lambda (x y)
            (if EQUx QU
                (if EQUy x
                    (if EHHy x HTHy (g x Ty))))))
      Devcon Y
        (lambda (g)
          (lambda (c a)
            (if (f HHc a) (f HTHc a) (g Tc a))))
      Devlis Y
        (lambda (g)
          (lambda (m a)
            (if EQUm QU P (f Hm a) (g Tm a))))
      (if NP?e (assoc e a)
          (if NP?He
              (if EHe Qquote HTe
                  (if EHe Qatom NP? (f HTe a)
                      (if EHe Qeq E (f HTe a) (f HTTe a)
                          (if EHe Qcar H (f HTe a)
                              (if EHe Qcdr T (f HTe a)
                                  (if EHe Qcons P (f HTe a) (f HTTe a)
                                      (if EHe Qcond
                                          (evcon Te a)
                                          (f P (assoc He a) Te a))))))))
              (if EHHe Qlabel
                  (f PHTTHe Te P (list HTHe He) a)
                  (if EHHe Qlambda
                      (f HTTHe (append (zip HTHe (evlis Te a)) a))
                      Qerror))))))

(eval '(quote a) '())
(eval ''a '())
(eval '(quote (a b c)) '())

(eval '(atom 'a) '())
(eval '(atom (quote (a b c))) '())
(eval '(atom '()) '())
(eval '(atom (atom 'a)) '())
(eval '(atom (quote (atom 'a))) '())

(eval '(eq 'a 'a) '())
(eval '(eq 'a 'b) '())
(eval '(eq '() '()) '())

(eval '(car '(a b c)) '())
(eval '(cdr '(a b c)) '())

(eval '(cons 'a '(b c)) '())
(eval '(cons 'a (cons 'b (cons 'c '()))) '())
(eval '(car (cons 'a '(b c))) '())
(eval '(cdr (cons 'a '(b c))) '())

(eval '(cond ((eq 'a 'b) 'first) ((atom 'a) 'second)) '())

(eval '((lambda (x) (cons x '(b))) 'a) '())
(eval '((lambda (x y) (cons x (cdr y))) 'z '(a b c)) '())
(eval '((lambda (f) (f '(b c))) '(lambda (x) (cons 'a x))) '())

(eval '((label subst (lambda (x y z)
                       (cond ((atom z)
                              (cond ((eq z y) x) (#true z)))
                             (#true
                              (cons (subst x y (car z))
                                    (subst x y (cdr z)))))
                       ))
        'm 'b '(a b (a b c) d))
      '())

